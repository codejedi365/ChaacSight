#!/bin/sh
# git-hook: prepare-commit-msg
# --------------------------------------

# shellcheck source=scripts/.git-hooks/_/husky.sh
. "$(dirname "$0")/_/husky.sh"

[ -z "$LOG_PREFIX" ] && LOG_PREFIX="[scripts/.git-hooks/prepare-commit-msg]"
[ -z "$CZ_RETRY" ] && CZ_RETRY=false

# shellcheck source=scripts/.git-hooks/hook-utils.sh
. "$(dirname "$0")/hook-utils.sh"

# GIT HOOK ARGV
# ------------------------
COMMIT_MSG_FILE="$1" # .git/MERGE_MSG | .git/SQUASH_MSG | .git/COMMIT_EDITMSG
COMMIT_MSG_SOURCE="$2" # message | template | merge | squash | commit
# COMMIT_OBJ_NAME="$3" # commit object name

if [ "$COMMIT_MSG_SOURCE" = "merge" ] ||
    [ "$COMMIT_MSG_SOURCE" = "message" ] ||
    [ "$COMMIT_MSG_SOURCE" = "commit" ] ||
    [ "$COMMIT_MSG_SOURCE" = "squash" ]; then
    # on cherry-pick, merge commit, or amend commit, do not enable commitizen
    # and pass on succesfully
    unset -v COMMIT_MSG_SOURCE
    cleanup
    exit 0
fi

# Default
# run as dry run to write to file only and exit with success (use as git hook)
CZ_OPTIONS="--write-message-to-file $COMMIT_MSG_FILE --dry-run"

# if [ "$CZ_RETRY" = "true" ]; then   # Currently not supported by py-commitizen due to no true backup
#     CZ_OPTIONS="--retry"
# elif ! exec </dev/tty; then
if ! exec </dev/tty; then
    error "Unable to activate <stdin> for interactive shell for commitizen cli"
    error "Aborting interactive commit..."
    unset -v COMMIT_MSG_FILE COMMIT_MSG_SOURCE CZ_OPTIONS
    cleanup
    exit 0
fi

if [ -e "$VIRTUAL_ENV/bin/cz" ]; then
    COMMITIZEN_CMD="$VIRTUAL_ENV/bin/cz cz commit $CZ_OPTIONS"

    log "Starting commitizen cli for conventional commits..."
    explicit_run_cmd "${COMMITIZEN_CMD} || (exit 0)"
    unset -v COMMIT_MSG_FILE COMMITIZEN_CMD
else
    error "ERROR: Unable to find commitizen cli"
fi

# env cleanup (vars, functions, utils)
unset -v COMMIT_MSG_FILE COMMIT_MSG_SOURCE CZ_OPTIONS
cleanup
